#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port3,           rearLeft,      tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port4,           rearRight,     tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex269, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// In order for the trigonometry functions to work correctly, all drivetrain motors
// should have a +PWM value corresponding to a clockwise rotation on the wheel.

#include "HolonomicRadians.h";

typedef enum {
	left = 1,
	center = 2,
	right = 4
} cLCDButtons;

task main()
{
	//Option 1: Use LCD Screen or Ch8 joystick buttons to cycle through all multiples of PI/4 for [0,2PI)
	bool leftLCDPressed = false;
	bool rightLCDPressed = false;
	bool leftJoyPressed = false;
	bool rightJoyPressed = false;
	bool centerLCDPressed = false;
	bool downJoyPressed = false;
	bool killSwitch = false;
	int radianMultiplier = 0;
	bLCDBacklight = true;
	while(true)
	{
		// Check the left LCD Button for changes
		if(nLCDButtons == left && !leftLCDPressed)
		{
			radianMultiplier--;
			leftLCDPressed = true;
		}
		else if(nLCDButtons != left) leftLCDPressed = false;

		// Check the right LCD button for changes
		if(nLCDButtons == right && !rightLCDPressed)
		{
			radianMultiplier++;
			rightLCDPressed = true;
		}
		else if(nLCDButtons != right) rightLCDPressed = false;

		// Check the left Ch 8 button for changes
		if(vexRT[Btn8L] && !leftJoyPressed)
		{
			radianMultiplier--;
			leftJoyPressed = true;
		}
		else if(!vexRT[Btn8L]) leftJoyPressed = false;

		// Check the right Ch 8 button for changes
		if((vexRT[Btn8R]) && !rightJoyPressed)
		{
			radianMultiplier++;
			rightJoyPressed = true;
		}
		else if(!vexRT[Btn8R]) rightJoyPressed = false;

		// Check the center LCD button for changes
		if(nLCDButtons == center && centerLCDPressed == false) {
			killSwitch = killSwitch ? false : true;
			centerLCDPressed = true;
		}
		else if(nLCDButtons != center) centerLCDPressed = false;

		// Check the right Ch8 Button for changes
		if(vexRT[Btn8D] && !downJoyPressed)
		{
			killSwitch = killSwitch ? false : true;
			downJoyPressed = true;
		}
		else if(!vexRT[Btn8D]) downJoyPressed = false;

		// We want the values to cycle, so when we go beyond bounds, go to the start of the opposite bound
		if(radianMultiplier > 7) radianMultiplier = 0;
		if(radianMultiplier < 0) radianMultiplier = 7;


		displayLCDCenteredString(0,"Cycling Holonomic");
		switch(radianMultiplier)
		{
			case 0: displayLCDCenteredString(1,"Direction: 0"); 	 	break;
			case 1: displayLCDCenteredString(1,"Direction: PI/4"); 	break;
			case 2: displayLCDCenteredString(1,"Direction: PI/2"); 	break;
			case 3: displayLCDCenteredString(1,"Direction: 3PI/4"); break;
			case 4: displayLCDCenteredString(1,"Direction: PI"); 		break;
			case 5: displayLCDCenteredString(1,"Direction: 5PI/4"); break;
			case 6: displayLCDCenteredString(1,"Direction: 3PI/2"); break;
			case 7: displayLCDCenteredString(1,"Direction: 7PI/4"); break;
			default: displayLCDCenteredString(1,"ERROR");
		}
		if(!killSwitch) HolonomicRadianOutput((0+((float)radianMultiplier*(PI/4))),1,0); // the last 1,0 is optional, as it is defaulted to those vals
		if(killSwitch)
		{
			motor[frontLeft] = 0;
			motor[frontRight] = 0;
			motor[rearRight] = 0;
			motor[rearLeft] = 0;
		}
	}
	// End of Option 1

	// Option 2: Full Joystick Control
}
